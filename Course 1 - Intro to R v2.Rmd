---
title: \vspace{3.5in} "Putting the R in ScHARR"
author: "Robert Smith"
date: "`r format(Sys.time(), '%d. %B %Y')`"
output:
  
  html_document: default
  word_document: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage 

\tableofcontents

\newpage 



\newpage 

## Introduction to R
This series of short courses are designed to equip the participant with a basic set of tools to undertake research using R. The aim is to create a strong foundation on which participants can build skills and knowledge specific to their research and consultancy objectives. The course makes use of the authors' experiences (many of which were frustrating) of working with R for data-science and statistical analysis. However there are many other resources available, and we would particularly recommend the freely available content at *[R for Data Science](https://r4ds.had.co.nz/)* as a good place to recap the materials taught in this course. The hard copy of Hadley Wickham and Garrett Grolemund's book of the same name (and content) is available at *[Amazon.com](https://r4ds.had.co.nz/)*. Alternatively, a user guide is available on the CRAN R-Project website [here](https://cran.r-project.org/doc/manuals/r-release/R-intro.html), although the author finds this less easy to follow than Hadley Wickham's book described above. Further details of where to go to answer more specific questions are provided throughout the course.

Requirements: It is assumed that all participants on the course have their own laptop, and have previously used software such as Excel or SPSS. Some basic understanding of statistics and mathematics is required (e.g. mean, median, minimum, maximum).


## Who we are:

*[Robert Smith](https://www.linkedin.com/in/robert-smith-53b28438/)* is a PhD Candidate at ScHARR, funded by the Wellcome Trust Doctoral Training Centre in Public Health Economics and Decision Science. His focus is on the methods used to estimate the costs and benefits of public health interventions, with a specific interest in microsimulation modelling (done in R). He has become increasingly intersted in the use of R-Markdown and R-Shiny to make research more transparent and to aid decision makers. While doing his PhD, Robert has been involved in projects with the WHO, Parkrun and Western Park Sports Medicine.

Paul Schneider ...

Sarah Bates ...

Thomas Bayley ...

Naomi Gibbs ...

\newpage

# Series of Short Courses in R.

We have put together content for a series of short courses in R. These  courses are designed to provide the user with the necessary skills to utilise R to answer questions using data. By the end of the series a user should be able to manage data efficiently, analyse relationships between variables and display this in aesthetically pleasing graphs, run simulations, feed back on methods and create apps to facilitate the decision making process. The objective is to give the user an understanding of what is possible, and the foundation on which to achieve it.

### Course 1 Aims:
By the end of the 1 day short course, the attendee should be able to:

* Install and navigate R Studio. Set working directory.
* Understand the types of objects and basic operations in R.
* Read in data from csv and excel files.
* Summarise data. 
* Perform basic regression analysis on data.
* Create basic plots and graphs.
* Use an 'if' function
* Create a loop
* Know where to find further information (StatsExchange/Google).

### Course 2 Aims:
By the end of the 1 day short course, the attendee should be able to:

* Create beautiful graphs using ggplot.
* Use the 'apply()' function to improve run-time.
* Create a custom function.
* Know where to find further information (StatsExchange/Google).

### Course 3 Aims
By the end of 1 day short course, the attendee should also be able to:

* Understand the strengths and limitations of R for HTA.
* Create a markov model from scratch given known parameters.
* Create a microsimulation model to incorporate hetrogeneity between groups.
* Understand the importance of tranparency of coding. In particular commenting.

### Course 4 Aims
By the end of the 1 day short course, the attendee should be able to:

* Understand the benefits and limitations of R-Shiny.
* Have a basic understanding of the principles behind R-Shiny.
* Create an R-Shiny application from scratch.
* Integrate beautiful plots into R-Shiny.
* Develop a user interface for an existing complex model in R-Shiny.

### Course 5 Aims
By the end of the 1 day short course, the attendee should be able to:

* Understand the strengths and limitations of R-Markdown.
* Create replicatable HTML, Word and PDF documents using R-Markdown.
* Include chunks of code, graphs, references and biblographies, links to websites and pictures.
* Change replicate analysis for new or updated datasets, or create templates for routine data.
* Create markdown presentations.

\newpage

\vspace{3.5in} 

# Course 1 - Introduction to R.

\newpage

## Install and navigate R Studio.

R is a free software environment for statistical analysis and data science. It is a collaborative effort started by Robert Gentleman and Ross Ihaka in New Zealand, but now made up of hundreds of people. R is made freely available by the Comprehensive R archive Network (CRAN), in the UK it can be downloaded through the University of Bristol [here](https://www.stats.bris.ac.uk/R/). 

Downloading R gives you the basic software environment, but an incredibly popular add-on called 'RStudio' is required to follow this course. You should download the free 'RStudio Desktop Open Source Licence' version for the laptop you will be attending the course with from [RStudio.com](https://www.rstudio.com/products/rstudio/#Desktop).

If you have time before the course, it would be hugely beneficial to get familiar with RStudio.

**Objectives:**

> Download R from <https://www.stats.bris.ac.uk/R/>.  
> Download RStudio from <https://www.rstudio.com/products/rstudio/#Desktop>.

## Basics

Our course starts in the R console, which those of you who are familiar with R but not RStudio will recognise. We will enter commands as input into the console, and receive output from the console. We will start with some simple basic operations, for which R is clearly very excessive.

### Basic operations
Entering 1+1, we get the output [1] 2. The output is 2, but the [1] lets us know that the number 2 is the first number of output. If we had an output that was particularly large (e.g. 100 seperate numbers) then r may let us know that the first row displayed starts with the first value [1] and the second row starts with the [x]th value. 

```{r,echo=TRUE}

rm(list = ls())

# add 1 to 1. 
1 + 1

# divide 12 by 4
12/4

# times 3 by 7
3*7

# 10 to the power 3
10^3

# root isn't a basic operation so we will look at later.
```

### Objects
It is possible to create objects, an object can take a number of forms (e.g. a number, a vector of numbers, a matrix, a data-frame). We can then use these objects going forward rather than the values directly. Operations can be applied to these objects, and objects can be over-written. R is basically just objects and functions.

```{r,echo=TRUE}

# objects basics
x <-  3
y <-  5
x + y
 
x <-  4
x + y
  
z <- x + y
z

```

### Overwriting / Manipulating Objects

```{r,echo=TRUE}

 
a <- 10
a

a <- a + 1 
a 

```

**Exercises**

set d equal to 10.
divide d by 5
multiply d by 8
add 8 to d 
what is d?

### Evaluations
We can perform evaluations, which provide a true or false answer. For example the input 4>2 returns "FALSE". 

It can be very useful in cases where an outcome is binary (e.g. an individual dies or remains alive). Or where we want to change a continous variable to a binary.

```{r,echo=TRUE}

# simple evaluations
# 4 is greater than 2
4 > 2
# 4 is greater than 5
4 > 5
# 4 is equal to 3, note double == for an evaluation
4 == 3
# 4 is not equal to 3, note != is not equal to.
4 != 3
# the character x is equal to the character x.
"dog" == "dog"
"dog" == "cat"

# the output from an evaluation can be stored as an object, x. This object can be subject to operations & manipulations.
b <- 4<2
b
```


### Different object classes and types
Objects don't have to take a single value. For example a single object may be the heights of each child in a group of children (in the example below a small class of 4).

We have been working with single values, which are vectors of 1. To illustrate the different classes we are going to create some vectors.

### Object Classes
Different class include numeric, character, logical, integer & complex (ignore).
```{r,echo=TRUE}

# numeric
height <- c(1.72,1.78,1.65,1.90) # 1:4
height

# numeric
weight <- c(68,75,55,79)
weight
class(weight)

# character
first_name <- c("Alice","Bob","Harry","Jane")
first_name
#first_name + 1 # error

# factor
sex <- factor(x = c("F","M","M","F"))
sex

# logical
tall <- height > 1.8
```
### Operations on different data structures

#### Operations on Vectors

```{r, echo=TRUE}
#Adding:
c(1,2,3) + 1
c(1,2,3) + c(1,2,3)


#multiplication
heightft <- height*3.28


```
**Exercise**
Create a vector called 'odds' with the numbers 1,3,5,7,9.
Show what class odds is. 

Evaluate which numbers in the odd vector are greater than 4. 

Create a vector called 'fail' containing 1,3,5,'seven',9.
Show what class fail is.

Create a vector that gives everyone's weight in pounds (2.2lbs to kg)


### Basic object Types

There are multiple types of object in R. We can store objects together in a data-frame. In our example data-frame each column is a variable (height, weight, first_name), and each row is an individual. 

Different object types include:

Vector - single variable a 1x1 vector. Vector all elements same data-type. 
Matrix - all same data-type.
Dataframe - columns same data type.
List - anything goes.

```{r,echo=TRUE}

# data frame- columns are variables, rows are observations.
df <- data.frame(height,weight,first_name,sex)
df

# we can select a single variable within the dataframe using the dollar sign.
df$height

# We can add a new variable easily, in this case based on other variables within the dataframe.
df$bmi <- df$weight / df$height^2 
df
```

### Subsetting
We can subset our data, to reduce it to those we are interested in. This is useful when cleaning our data, and when changing a continuous variable to a categorical.
```{r,echo=TRUE}

# Our data-frame contains the height, weight, first name and bmi of 4 individuals.
df

#To subset a data frame we can use square brackets i.e df[row,column]
#Selecting a column(s)
df$height
df[,"height"]
df[,1]
df[,1:3]
df[,c(1,3)]

#selecting a row(s)
df[1,]

#We might also want to select observations (rows) based on characteristics of the data
#E.g. we might want to only look at the data for people who are taller than 1.75m

#create a logical variable called min_height which contains T/F for each individual being over 175cm.
min_height <- df$height >= 1.75
min_height

# Subset the data to include only those observations (rows) for which height > 175cm (using min_height).
df.at_least_175 <- df[min_height,]
df.at_least_175

#People smaller than 1.75m
# Subset the data to include only those who are not above min-height of 175cm.
smaller = df$height < 1.75
df[smaller,]
df[!min_height,]


```
Not that there are other more advanced methods, which uses pipes and require less code (these are covered in more advanced courses).

**Exercises**
select the 3rd row from the data frame

Select the weight variable from the data frame using your prefered method

Select alice's data from the data frame 

Subset the data frame to show just the data for the females

type df[,-1] what does this give



### Exercises

**Exercise 1**
Simple calculations

a) Calculate the following:

5*10
20/3

More complex calculations.
b) Calculate x where a = 20 b = 9, c = 5, d = 1.2
*you are only allowed to type each number once*

$x = 4b + 7c + 3d$

$x = \frac{8b + 4c -12d}{a}$



${12\times(a+b)}\over {x}$

**Exercise 2**
x <- c(10,30,4,52,60,7,8,10,12,15,14,17,19,20,25,30)
a) Which numbers in x are above 8
b) Which numbers are equal to 10.
c) Which numbers are below 8 or above 30.

d) Can you create a matrix with numbers and characters.
        names <- c("Anne","Tom","Jamie","Max","Claire")
        ages <- c(12,16,25,34,28)
        cbind(names,ages)
        What happens if you try to use the ages?


e) Create a dataframe for five individuals (Andrew, Betty, Carl, Diane and Elisa) who are aged (62,80,24,40,56) and have gender (male, female, male,female, female). 

f) Use evaluations and subsetting to find the characteristics of the individual who can claim their free bus pass (age 65+).

g) Create a variable in the dataframe called life expectancy, set this to 83 for females and 80 for males.

h) Create another variable called lyr (life years remaining) which is the number of years to life expectancy for each individual

\newpage 


## Understanding R. #SARAH

### What is an R Script
Show what an R Script is.

### Basic functions
Functions can be applied to make data manipulation easier. Many functions are included in baseR. For example mean. Mean returns the arithmetic mean of a vector of numbers. We can find out more about mean by entering ?mean.

```{r,echo=TRUE}
# find out more about mean
?mean

# create a vector of numbers
some_numbers = c(10,12,13,13,14,18,20)

# find the arithmetic mean of the numbers
average_value = mean(some_numbers)

#return the numbers
average_value
```

Other functions are more complex, requiring multiple inputs. For example **round** requires two inputs:
      x)   a value or multiple values
 digits)   the number of digits to round to. 

```{r,echo=TRUE}
# find more information about round
?round

# Rounding 5.7 to 0 digits gives 6.
round(x = 5.7,digits = 0)

# Rounding our average value to 2 digits gives 14.29.
round(average_value,2)

# We can do the same for multiple values
round(c(12.25,15.63,14.42),1)

```

Another useful function is sequence:

This requires the number to start from (*from*), the number to finish at (*to*), and the interval between numbers (*by*) in the sequence. Alternatively, instead of *by* the length of the sequence can be set using *length.out*.

```{r,echo=TRUE}
# find out more about sequence
?seq

# create a sequence of odds from 1 to 21.
seq(from = 1, to = 21, by = 2)

# create a sequence of length 10 from 1 to 21
seq(from = 1, to = 21, length.out = 10)
```

### Attributes
```{r,echo=TRUE}

# attributes
df
names(df)
#rownames(df) = c("row 1","row 2","row3") # error
rownames(df) = c("row 1","row 2","row3","row 4")
df

x
length(x)


str(df)
dim(df)

```

### Classes

```{r,echo=TRUE}

# classes
class(x)
class("this is a sentence")
class(df)

# matrix(1:9,ncol=3,nrow=3)

# the list
My_list = list(my_df = df,
               a_vector = x,
               another_one = y,
               some_text = c("foo","bar"))
My_list

My_list$a_vector

My_list$my_df

My_list[[1]]

My_list[[1]]$height

str(My_list)

# NA, Nan, Inf

```

### Environment
```{r,echo=TRUE}
# enviroment & wd
ls()
rm("y")
ls()
# attach(...)
rm(list=ls())
ls()
```

\newpage 

## Working with R. #Rob

### If Statements  
If statements allow us to perform different actions depending on a condition. The normal brackets contain the evaluation, the curly brackets the command if that evaluation is true.  For example here if(1 = 1)then print the number 2. 

```{r echo=TRUE}

if(1==2){
  print(2)
}
```


We can use this to assign risks to individuals based on characteristics. For example if an individual has a health condition (e.g. Type2Diabetes) they may have a higher risk of Heart Disease. Therefore if we know that individuals with diabetes have a 10% risk of Heart Disease and individuals without Type 2 Diabetes have a 3% risk of Heart Disease we could assign risk to an individual as follows:``

```{r echo=TRUE}
t2d <- 0

if(t2d==1){
  risk <- 0.1
}else{
  risk <- 0.03
}
```

This method can be combined with the next tool, loops, to assign risks for lots of individuals.

### Loops
There are numerous different ways to create loops, we are going to look at the simplist, the **for** loop which executes the command for each number given. 
```{r echo=TRUE}

 # Loop printing 1 to 10

for(i in 1:10) { # for each value of i from 1 to 10.
  print(i)       # print the value of i
}                # close the loop

```

We can also create an object, in this case a vector with the numbers we would like to loop through:

```{r echo=TRUE}

# create an object of odds
odds <- c(1,3,5,7,9)
 
# Loop printing all the values in the odds vector.
for(i in odds) { # for each value of i in the odds vector.
  print(i)       # print the value of i
}                # close the loop

```

If we create a vector, *ourdata*,  beforehand we can fill it with the output from each iteration of the loop. This is particularly useful if we want to record the output of a simulation.

```{r echo=TRUE}

#create an vector of empty data
ourdata <- vector(mode = "numeric",length = 10)
 
# Fill our vector with values
for(i in 1:length(ourdata)) { # for each value of i in our data object.
  ourdata[i] <- i             # print the value of i
}                             # close the loop

print(ourdata)                # print the vector

```
Having multiple loops can can sometimes make code very messy, an alternative is called apply. It *applies* (hence the name) the same function to multiple rows/columns. This is much tidier, especially where the function is complicated.

As an example, I create a dataset, a matrix of random numbers with 100 columns and 100 rows. I want to know the average of each row.

```{r,echo=FALSE}
squarelength <- 1e4

randnums <- matrix(data = runif(squarelength*squarelength,min = 0,max = 1),
                   nrow = squarelength,
                   ncol = squarelength)

temp <- vector(mode = "numeric",
               length = squarelength)


t <- Sys.time()

for(i in 1:100){
  temp[i] <- mean(randnums[i,])
}
print(Sys.time()-t)
```
In  this case using a function is much slower, but it does make the code tidier, which can be a bigger probem than model run-time. It is up for the programmer to decide which is more important.

```{r,echo=TRUE}
squarelength <- 1e4

randnums <- matrix(data = runif(squarelength*squarelength,min = 0,max = 1),
                   nrow = squarelength,
                   ncol = squarelength)

temp <- vector(mode = "numeric",
               length = squarelength)

# measure time to run
t <- Sys.time()

temp <- apply(X = randnums,
              FUN = mean, 
              MARGIN = 1)

print(Sys.time()-t)

```
### Custom Function
Creating custom functions is a huge strength of R. Calling scripts in STATA is possible, but not as tidy as in R. 

A function is a piece of script that is stored as an object. A function generally takes a user input, performs some actions based on the statements in the function, and returns some output. It is possible to write a script that uses no functions, but using them can reduce unncessary replication of long sections of code, thereby making work easier to follow. 

There are many functions predefined in base R. *Mean* is an obvious example. Custom functions can also be defined within a script, or called from another R-Script using *source*.

An example function is shown below. The function simply takes a temperature, and a conversion (Celsius to Fahrenheit = True, Fahrenheit to Celsius = False), and returns the converted temperature. The function has the name *temperature_converter*, it uses two inputs:
          x      : a scalar or vector of numbers
          c_to_f : if True then converts celsius to fahrenheight, if FALSE then converts fahrenheight to celsius.
          
```{r,echo=TRUE}
# my function
temperature_converter = function(x,c_to_f = T){
  if(c_to_f){
    temp = x * 9/5 + 32 
  } else {
    temp = (x - 32) * 5/9
  }
  return(temp)
}

temperature_converter(c(40,30,20,10,0),c_to_f = T)
```

When creating custom functions it is important to ensure that you don't overwrite an existing function. For example, we can create the function *mean* which does not return the arithmetic mean of a vector of numbers, but instead prints an unkind message.

```{r,echo=TRUE}

mean = function(x){
  print("You are a buffoon")
}
mean(c(15,10,40,32,18))

```

**Exercise 1**

Create a function which multiplies three input numbers together

```{r,echo=FALSE,eval=FALSE}

multiply_these = function(x,y,z){
  temp <- x*y*z
    
  return(temp)
}

multiply_these(10,5,1)
```

**Exercise 2**
  
Create a function which divides a number by 37, then rounds the number to 2 decimal places. I find it easier to do things one step at at time. In this case I would create a temporary object which was the value of the number divided by 37, then round the temporary number to two digits, overwriting the original temporary object. I would then return that temporary number.

```{r,echo=FALSE,eval=FALSE}

learning_function = function(x){
  
  temp <- x/37
  
  temp <- round(x= temp,
                digits = 2
                )
    
  return(temp)
}

learning_function(12)
```

**Exercise 3**

Calculate, in real terms, the present value of stream of annual monetary benefits received at the start of each yearfor 10 years, given a user specified discount rate

```{r,echo=FALSE,eval=FALSE}

calc_presval = function(init_val,d.r){
  
    temp <- init_val/(1+d.r)^(0:9)
    
    return(temp)
}

# Value of 100, received at the start of every year for 10 years. Discounted at a rate of 3%.
calc_presval(init_val = 100,
             d.r = 0.03)
```

### Packages

Creating all your functions from scratch is a lot of work, where others have previously created the same functions, why reinvent the wheel? Instead we can stand on the shoulders of others by downloading 'packages'. Packages usually contain functions, and sometimes example datasets or datasets which enable a user to do certain things (e.g. plot a world map). Importantly though, we must understand what the functions within these packages are doing if we are going to use them.

A package can be installed from CRAN using the function *install.packages()* with the name of the package in "". Packages can also be installed from Github, but this is covered later. 



```{r,echo=TRUE,eval=FALSE}
#install.packages("stats")
#devtools::install_github("hadley/babynames")
```

To find more information about the babynames package you can type

```{r,echo=TRUE,eval=FALSE}

#help(package = "babynames")
```

To load the downloaded package from the file it was downloaded to you can type:

```{r,echo=TRUE,eval=FALSE}

#library(babynames)
#ls("package:babynames")
#View(babynames)
```

In this package there is just a dataset of baby names. However other packages allow you to do certain things. In many cases there are lots of different options. For example the rworldmap package contains data on country boundaries and enables the user to create custom maps. For a really simple map see the example below:

```{r,echo=TRUE,eval=FALSE}
#install.packages("rworldxtra")
#install.packages("mapdata")
#library(rworldxtra)

#newmap <- getMap(resolution = "high")
#
#plot(newmap, 
#     xlim = c(-10, -2), 
#     ylim = c(50, 62), 
#     asp = 1)
#
#points(x = -1.480840, 
#       y= 53.380720, 
#       col = "red",
#       pch =  16, 
#       cex = 1)
#
#text(x = -1.480840, 
#     y = 53.380720,
#     labels = "Sheffield",
#     pos = 1,
#     col = "red")

```

## Doing Research in R # Tom


### Importing Data

In almost every case, you will want to import some data to analyse. This data will come in a variety of formats. R studio has a nice feature in Environment>Import_Dataset which enables you to select the file you wish to download (similar to STATA) from your computer. The data is then imported into R and the code available in the console.

It is possible to import files in the following formats:

|  Type  | Suffix     | 
|--------|:----------:|
| R      |.R          |
| CSV    |.csv        |
| Excel  |.xls/.xlsx  |
| SPSS   |.spv        |
| Stata  |.dta        |


Alternatively packages can be installed to import data in almost any format. For example the readr package can read in spreadsheets from text files or tab delimited files.


#### CSV (Comma-seperated values)
We can import the file using the full path with the file name and suffix included such as below:

```{r,echo=TRUE,eval=FALSE}

```

#### Setting Working Directory
If you know that you will be reading and writing multiple files from the same folder, you can set a working directory. The working directory is the defined folder in which R will then import and export files from and to. This allows users to send whole files to others who can replicate the work by simply changing the working directory to the new file location. 

The current working directory can be found by typing:

```{r,echo=TRUE}
getwd()
```

A new working directory can be set by clicking on the tab (Session) then (Set_Working Directory), or by the command setwd:

```{r,echo=TRUE,eval=FALSE}
# filename = "C:/Users/Robert/Documents"
setwd(filename)
```

#### Downloading files from the internet

Sometimes it is more practical to download files directly from the internet. There are lots of different packages out there to do this. The one I use was developed by Hadley Wickham, called readr. Here we are going to download some data from the github page for the course.

```{r,echo=TRUE,eval=FALSE}
# load the readr package, if this is not installed then install it.
library(readr)

#use the function read_csv
#data <- read_csv("https://raw.githubusercontent.com/RobertASmith/Intro_to_R/master/Data/who_complete.csv")
```

Downloading files directly to R within the same script as the analysis can be useful since it reduces the risk of you accidently changing the file. Just be careful that the data will always be available. 

### Summarising Data

Once we have our data read into R, we want to ensure that the data is as we would expect, in the correct format etc. 

We can use the function *head* to look at the first 6 number of lines of the data. We can specify a different number of lines by chancing the function input.

```{r,echo=TRUE,eval=FALSE}
library(babynames)

# head data with default 6 rows
head(babynames)

# head data with 10 rows
head(babynames, n = 10)

```
We can summarise a dataset using the function *summary*. This shows us the length, class and Mode. If the class is numeric it will give some indication of the distribution by displaying min, median, mean, max. 

```{r,echo=TRUE,eval=FALSE}

# summarise the data, 
summary(babynames)

# summarise single variable
summary(babynames$prop)

```
### Summarising
Data-frames

Summarise data-frame:

```{r,echo=TRUE}
# We can summarise our data-frame with height, weight, first name and BMI.
summary(df)

# The data-frame height variable is numeric, will return quantiles.
summary(df$height)

# The data-frame first-name lists the first name and number (character)
summary(df$first_name)

```

We can use the output of the summary function to create objects. The summary of the year variable gives the quantiles. These can be stored as an object, here called temp (temporary object). If we just want any one number from the vector of quantiles we can define this in brackets. The script below creates two new objects, median and range.

```{r,echo=TRUE,eval=FALSE}

temp <- summary(babynames$year)

Median  <- temp['Median']
Range   <- temp['Max.'] - temp['Min.']

```

### Plotting Data

*Line Plot*
It is also possible to plot the data provided. If we subset the babyname data, limiting the data to females called Mary we can plot the incidence in Marys over time. The function to do this is *plot*. Plot requires a vector of x and a vector of y. If x is not specified y is plotted against Index (1= first observation in index ... and so on).

```{r,echo=TRUE,eval=FALSE}
subname <- "Donald"
temp <- subset(babynames,
               name == subname & sex=="M")

# a basic plot, just a scatter plot but with year on the x axis.
#plot(y = temp$prop,
#     x = temp$year)
```

However, this plot looks quite messy:

1) It is lots of points rather than a line.
2) We have weird axis names.
3) The Y axis numbers are awkward.
4) There is no title.

```{r,echo=TRUE, fig.height=5, fig.width=8, r,echo=TRUE}

plot(y = temp$prop*1000,
     x = temp$year,
     type = "l",
     xlab = "Year",
     ylab = paste(subname," per 1000"),
     main = paste("Number of newborns named", subname, ", United States 1880 to 2017")
    )
```

We can also plot a histogram of how prevalent a name is. The command *hist* does this.

```{r,echo=TRUE, fig.height=5, fig.width=8, r,echo=TRUE}
subname == "Matthew"

temp <- subset(babynames,
               name == subname & sex=="M")

hist1 <- hist(temp$prop,breaks = seq(0,0.05,by=0.005))

plot(hist1)

# we can add a density line in simply using the function *density*.
lines(density(x = temp$prop))

```

### Basic Regression

R is designed for statistical analysis. It therefore has simple inbuilt commands for regression. We can use an example dataset which has information about cars:

```{r,echo=TRUE, fig.height=5, fig.width=8, r,echo=TRUE}

plot(x = cars$speed,
     y = cars$dist,
     type = "p",
     xlab = "speed",
     ylab = "distance")

# correlation is quite high:
cor(cars$speed, cars$dist)

# we can use a linear model to estimate the relationship between speed and distance. 
lm_cars <- lm(dist ~ speed, data=cars) 

# we can then print to see the intercept and beta.
print(lm_cars)

# we can see more information including std. error, p value etc here:
summary(lm_cars)

# As before, we can create an object with one part of this information by subsetting just the coefficients.
lm_coeff <- summary(lm_cars)$coefficients

# Then, for example if we want the intercept we can do:
lm_coeff["(Intercept)","Estimate"]
# Or the standard error of the speed:
lm_coeff["speed", "Std. Error"]

# we can predict distance from a set of speeds using predict. This command predicts the value of distance given a speed. We could do this simply using the equation Intercept + beta*Speed.
dist_speed5 <- lm_coeff["(Intercept)","Estimate"] + lm_coeff["speed", "Estimate"]*5
print(dist_speed5)

# or by predicting from a dataframe
speed <- 5
df <- as.data.frame(speed) 

distPred <- predict(lm_cars,
                    newdata = df)
print(distPred)

# we can plot estimates derived using our original data by simply predicting and leaving out the new-data option:
distPred <- predict(lm_cars)

plot(x = cars$speed,
     y= cars$dist)

lines(x=cars$speed, 
      y= distPred,col = "red")

```

### Basic Simulation
Sometimes we want to create a simple simulation, moving entities through time and having events occur. This is particularly useful in health economics.


We can do much more complex calculations within loops, the sky is the limit, but here are two examples.


**Example 1**
Example 1 is an example of discounting each year simply by multiplying the previous year value by (1/(1+d.r)).

```{r echo=TRUE}

#create an vector of empty data
v.val <- vector(mode = "numeric",length = 100)

# start with 1
v.val[1] <- 1
 
# Discount our value at 1.5% each year
for(i in 2:length(v.val)) {            # for each value of i in the odds object.
  
  v.val[i] <- v.val[i-1]* (1/1.015)    # it takes the value of the previous year value 1/(1.015)

  }                                      # close the loop

plot(v.val,type="l")                           # print the vector

```

An important lesson though, it is often possible to achieve a goal without loops, which is much faster in R when running big simulations. In this case we could have achieved the same result with the following, much simpler code:

```{r echo=TRUE}

v.val <- (1/1.015)^(1:100)

plot(v.val,type = "l")

```

**Example 2**
Example 2 records the survival of 1000 individuals who die with probability 0.1 in any given year.

```{r echo=TRUE}

#create an vector of empty data
m.ind <- matrix(data = NA,
                nrow = 100,
                ncol = 1000)

# everyone starts alive (1) 
m.ind[1,] <- 1
 
# Each person has a probability of death of 0.1
for(i in 2:nrow(m.ind)) { 
  
  # value is 1 if alive in previous period and random number > 0.1 
  m.ind[i,] <- m.ind[i-1,] * runif( n = 1000, min = 0, max=1 ) > 0.1  
}                                      # close the loop

plot(rowSums(m.ind),type="l")   # print the sums of the rows of the matrix (% alive)

```

